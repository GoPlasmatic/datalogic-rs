<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataLogic-rs Tutorial - Expression Evaluation Engine</title>
    
    <!-- Material Design -->
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <!-- Code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        .tutorial-nav {
            background-color: #f7f9fc;
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 24px;
        }
        .tutorial-nav h3 {
            margin-top: 0;
        }
        .tutorial-nav-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
        }
        .tutorial-nav-list li {
            margin-right: 16px;
            margin-bottom: 8px;
        }
        .tutorial-nav-list a {
            text-decoration: none;
            color: #6200ee;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .tutorial-nav-list a:hover {
            background-color: rgba(98, 0, 238, 0.08);
        }
    </style>
</head>
<body class="mdc-typography">
    <div class="container">
        <header class="mdc-top-app-bar">
            <div class="mdc-top-app-bar__row">
                <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-start">
                    <h1 class="mdc-typography--headline4">DataLogic-rs</h1>
                </section>
                <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-end">
                    <nav class="navigation">
                        <a href="index.html" class="mdc-button">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">Home</span>
                        </a>
                        <a href="tutorial.html" class="mdc-button mdc-button--unelevated">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">Tutorial</span>
                        </a>
                        <a href="operators.html" class="mdc-button">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">Operators</span>
                        </a>
                        <a href="playground.html" class="mdc-button">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">Playground</span>
                        </a>
                        <a href="https://github.com/codetiger/datalogic-rs" class="mdc-button" target="_blank">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">GitHub</span>
                        </a>
                    </nav>
                </section>
            </div>
        </header>

        <main class="main-content">
            <h1 class="mdc-typography--headline4">Getting Started with DataLogic-rs</h1>
            
            <!-- Tutorial Navigation -->
            <div class="tutorial-nav mdc-card">
                <h3 class="mdc-typography--subtitle1">Jump to Section</h3>
                <ul class="tutorial-nav-list">
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#installation">Installation</a></li>
                    <li><a href="#basic-usage">Basic Usage</a></li>
                    <li><a href="#complex-rules">Complex Rules</a></li>
                    <li><a href="#core-api-methods">Core API Methods</a></li>
                    <li><a href="#arena-memory">Arena Memory Management</a></li>
                    <li><a href="#custom-operators">Custom Operators</a></li>
                    <li><a href="#wasm-support">WebAssembly Support</a></li>
                    <li><a href="#next-steps">Next Steps</a></li>
                </ul>
            </div>
            
            <section id="introduction" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Introduction</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs is a powerful expression evaluation engine for Rust that implements the
                    JSONLogic specification and will support additional expression formats in the future. 
                    This tutorial will guide you through setting up and using DataLogic-rs in your Rust projects.
                </p>
            </section>
            
            <section id="installation" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Installation</h2>
                <p class="mdc-typography--body1">
                    Add DataLogic-rs to your <code>Cargo.toml</code> file:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-toml">[dependencies]
datalogic-rs = "3.0.7"</code></pre>
                </div>
            </section>
            
            <section id="basic-usage" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Basic Usage</h2>
                <p class="mdc-typography--body1">
                    Here's a simple example of how to use DataLogic-rs:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

fn main() {
    // Create a new DataLogic instance
    let dl = DataLogic::new();
    
    // Define a rule and data
    let rule_str = r#"{"==":[{"val":"temperature"},0]}"#;
    let data_str = r#"{"temperature":0}"#;
    
    // Evaluate the rule against the data
    let result = dl.evaluate_str(rule_str, data_str, None).unwrap();
    
    println!("Result: {}", result); // Prints: true
}</code></pre>
                </div>
                
                <p class="mdc-typography--body1">
                    This example checks if the temperature in the data is equal to 0.
                </p>
            </section>
            
            <section id="complex-rules" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Working with Complex Rules</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs can handle complex rules and data structures:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

fn main() {
    let dl = DataLogic::new();
    
    // A complex rule that filters items based on their quantity
    let rule_str = r#"{
        "filter": [
            {"val": "items"}, 
            {">=": [{"val": "qty"}, 2]}
        ]
    }"#;
    
    let data_str = r#"{
        "items": [
            {"id": "apple", "qty": 1},
            {"id": "banana", "qty": 3},
            {"id": "orange", "qty": 2}
        ]
    }"#;
    
    let result = dl.evaluate_str(rule_str, data_str, None).unwrap();
    
    println!("Items with qty >= 2: {}", result);
    // Prints items that have qty >= 2 (banana and orange)
}</code></pre>
                </div>
            </section>
            
            <section id="core-api-methods" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Core API Methods</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs provides three core methods for evaluating rules against data:
                </p>

                <h3 class="mdc-typography--subtitle1">1. evaluate</h3>
                <p class="mdc-typography--body1">
                    The <code>evaluate</code> method evaluates a compiled rule against a parsed data context.
                    This is useful when you need to reuse the same rule or data multiple times.
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

fn main() {
    let dl = DataLogic::new();
    
    // Parse the rule and data separately
    let rule = dl.parse_logic(r#"{ ">": [{"var": "temp"}, 100] }"#, None).unwrap();
    let data = dl.parse_data(r#"{"temp": 110}"#).unwrap();
    
    // Evaluate the rule against the data
    let result = dl.evaluate(&rule, &data).unwrap();
    
    println!("Result: {}", result); // Prints: true
}</code></pre>
                </div>

                <h3 class="mdc-typography--subtitle1">2. evaluate_str</h3>
                <p class="mdc-typography--body1">
                    The <code>evaluate_str</code> method combines parsing and evaluation in a single step.
                    It's ideal for one-time evaluations or quick scripting.
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

fn main() {
    let dl = DataLogic::new();
    
    // Parse and evaluate in one step
    let result = dl.evaluate_str(
        r#"{ "abs": -42 }"#,
        r#"{}"#,
        None
    ).unwrap();
    
    println!("Result: {}", result); // Prints: 42
}</code></pre>
                </div>

                <h3 class="mdc-typography--subtitle1">3. evaluate_json</h3>
                <p class="mdc-typography--body1">
                    The <code>evaluate_json</code> method works directly with serde_json Values.
                    This is useful when you're already working with JSON data in your application.
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;
use serde_json::json;

fn main() {
    let dl = DataLogic::new();
    
    // Use serde_json's json! macro to create JSON values
    let logic = json!({"ceil": 3.14});
    let data = json!({});
    
    // Evaluate using the JSON values directly
    let result = dl.evaluate_json(&logic, &data, None).unwrap();
    
    println!("Result: {}", result); // Prints: 4
}</code></pre>
                </div>
                
                <p class="mdc-typography--body1">
                    Choose the method that best fits your use case based on whether you need to reuse rules/data
                    and your preferred input format.
                </p>
            </section>
            
            <section id="arena-memory" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Arena-Based Memory Management</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs uses arena-based memory management for high-performance allocation and deallocation,
                    which is particularly important when processing many rules or working with large datasets.
                </p>
                
                <h3 class="mdc-typography--subtitle1">What is Arena Allocation?</h3>
                <p class="mdc-typography--body1">
                    Arena allocation (also known as "bump allocation") offers several key advantages:
                </p>
                <ul class="mdc-typography--body1">
                    <li>Memory is allocated in large, contiguous chunks</li>
                    <li>Individual allocations are extremely fast (just incrementing a pointer)</li>
                    <li>Memory is freed all at once instead of individually</li>
                    <li>Improved memory locality leads to better cache performance</li>
                </ul>
                
                <h3 class="mdc-typography--subtitle1">Resetting the Arena</h3>
                <p class="mdc-typography--body1">
                    For long-running applications, it's important to periodically reset the arena to free memory:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

fn main() {
    // Create a DataLogic instance with default settings
    let mut dl = DataLogic::new();
    
    // Evaluate some rules
    let result1 = dl.evaluate_str(r#"{ ">": [{"var": "temp"}, 100] }"#, r#"{"temp": 110}"#, None).unwrap();
    
    // Reset the arena to free memory
    dl.reset_arena();
    
    // Continue with new evaluations
    let result2 = dl.evaluate_str(r#"{ "<": [{"var": "count"}, 10] }"#, r#"{"count": 5}"#, None).unwrap();
    
    println!("Results: {}, {}", result1, result2);
}</code></pre>
                </div>
                
                <h3 class="mdc-typography--subtitle1">Tuning Arena Size</h3>
                <p class="mdc-typography--body1">
                    You can customize the chunk size used by the arena for better performance:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::DataLogic;

// Create a DataLogic instance with a 1MB chunk size
let mut dl = DataLogic::with_chunk_size(1024 * 1024);</code></pre>
                </div>
                
                <h3 class="mdc-typography--subtitle1">Processing Large Batches</h3>
                <p class="mdc-typography--body1">
                    For batch processing, reset the arena after each batch to prevent memory growth:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::{DataLogic, Result};

fn process_batches(batches: Vec<(String, String)>) -> Result<()> {
    let mut dl = DataLogic::new();
    
    for (rule_str, data_str) in batches {
        // Process each batch
        let result = dl.evaluate_str(&rule_str, &data_str, None)?;
        println!("Result: {}", result);
        
        // Reset the arena to free memory after processing a batch
        dl.reset_arena();
    }
    
    Ok(())
}</code></pre>
                </div>
                
                <p class="mdc-typography--body1">
                    For more detailed information on arena-based memory management, see the
                    <a href="https://github.com/codetiger/datalogic-rs/blob/main/ARENA.md" target="_blank">ARENA.md</a> document.
                </p>
            </section>
            
            <section id="custom-operators" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Custom Operators</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs provides two approaches for implementing custom operators:
                </p>
                
                <ul class="mdc-typography--body1">
                    <li><strong>CustomSimple</strong> - A simplified API that works with owned values, ideal for scalar operations</li>
                    <li><strong>CustomAdvanced</strong> - Direct arena access for maximum performance and complex data structures</li>
                </ul>

                <h3 class="mdc-typography--subtitle1">CustomSimple - Simplified Approach</h3>
                <p class="mdc-typography--body1">
                    The CustomSimple approach lets you work with operators as simple functions without worrying about arena allocation:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::{DataLogic, DataValue, SimpleOperatorFn};
use datalogic_rs::value::NumberValue;

// Define a simple custom operator that doubles a number
fn double<'r>(args: Vec<DataValue<'r>>, data: DataValue<'r>) -> std::result::Result<DataValue<'r>, String> {
    if args.is_empty() {
        // If no arguments provided, check for a value in the data context
        if let Some(obj) = data.as_object() {
            for (key, val) in obj {
                if *key == "value" && val.is_number() {
                    if let Some(n) = val.as_f64() {
                        return Ok(DataValue::Number(NumberValue::from_f64(n * 2.0)));
                    }
                }
            }
        }
        return Err("double operator requires at least one argument or 'value' in data".to_string());
    }
    
    if let Some(n) = args[0].as_f64() {
        return Ok(DataValue::Number(NumberValue::from_f64(n * 2.0)));
    }
    
    Err("Argument must be a number".to_string())
}

fn main() {
    let mut dl = DataLogic::new();
    
    // Register the simple custom operator
    dl.register_simple_operator("double", double);
    
    // Use the custom operator with an explicit argument
    let rule_str = r#"{"double":5}"#;
    let result = dl.evaluate_str(rule_str, "{}", None).unwrap();
    println!("Result: {}", result); // Prints: 10
    
    // Use the custom operator with data context
    let rule_str = r#"{"double":[]}"#;
    let data_str = r#"{"value":7}"#;
    let result = dl.evaluate_str(rule_str, data_str, None).unwrap();
    println!("Result from context: {}", result); // Prints: 14
}</code></pre>
                </div>

                <p class="mdc-typography--body1">
                    The CustomSimple approach is ideal for:
                </p>
                <ul class="mdc-typography--body1">
                    <li>Working with scalar values (numbers, strings, booleans)</li>
                    <li>Simpler implementation without arena management</li>
                    <li>Operations that don't require returning complex data structures</li>
                    <li>Direct access to the data context for more flexible operations</li>
                </ul>
                
                <h3 class="mdc-typography--subtitle1">CustomAdvanced - Arena-Based Approach</h3>
                <p class="mdc-typography--body1">
                    For more complex operations or when you need maximum performance, you can implement the <code>CustomOperator</code> trait:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">use datalogic_rs::{DataLogic, DataValue, CustomOperator};
use datalogic_rs::arena::DataArena;
use datalogic_rs::value::NumberValue;
use datalogic_rs::logic::Result;

// Define a custom operator that doubles a number
#[derive(Debug)]
struct DoubleOperator;

impl CustomOperator for DoubleOperator {
    fn evaluate<'a>(&self, args: &'a [DataValue<'a>], arena: &'a DataArena) -> Result<&'a DataValue<'a>> {
        if args.is_empty() {
            return Err("double operator requires at least one argument".into());
        }
        
        // Get the first argument value
        if let Some(num) = args[0].as_f64() {
            // Double it and return - allocated in the arena
            return Ok(arena.alloc(DataValue::Number(NumberValue::from_f64(num * 2.0))));
        }
        
        // Return null for non-numeric values
        Ok(arena.null_value())
    }
}

fn main() {
    let mut dl = DataLogic::new();
    
    // Register the custom operator
    dl.register_custom_operator("double", Box::new(DoubleOperator));
    
    // Use the custom operator
    let rule_str = r#"{"double":{"val":"value"}}"#;
    let data_str = r#"{"value":5}"#;
    
    let result = dl.evaluate_str(rule_str, data_str, None).unwrap();
    
    println!("Result: {}", result); // Prints: 10
}</code></pre>
                </div>
                
                <h3 class="mdc-typography--subtitle1">Working with Complex Data in CustomAdvanced</h3>
                <p class="mdc-typography--body1">
                    The CustomAdvanced approach lets you work directly with arrays and objects:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">#[derive(Debug)]
struct FilterEven;

impl CustomOperator for FilterEven {
    fn evaluate<'a>(&self, args: &'a [DataValue<'a>], arena: &'a DataArena) -> Result<&'a DataValue<'a>> {
        if args.is_empty() {
            return Ok(arena.empty_array_value());
        }

        if let Some(arr) = args[0].as_array() {
            // Filter numbers that are even
            let filtered: Vec<&DataValue> = arr
                .iter()
                .filter(|v| {
                    if let Some(n) = v.as_i64() {
                        n % 2 == 0
                    } else {
                        false
                    }
                })
                .collect();

            // Allocate the filtered array in the arena
            Ok(arena.alloc_array(&filtered))
        } else {
            Ok(arena.empty_array_value())
        }
    }
}</code></pre>
                </div>
                
                <h3 class="mdc-typography--subtitle1">Using Arena Allocation in CustomAdvanced</h3>
                <p class="mdc-typography--body1">
                    When implementing CustomAdvanced operators, always allocate results in the arena:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">// Basic allocation for simple values
Ok(arena.alloc(DataValue::Number(NumberValue::from_f64(value))))

// Working with strings
Ok(arena.alloc(DataValue::String(arena.alloc_str("my string"))))

// Working with arrays/collections
let mut temp_vec = arena.get_data_value_vec();
// Add elements to the vector
temp_vec.push(DataValue::Number(1.into()));
temp_vec.push(DataValue::Number(2.into()));

// Convert to a permanent slice in the arena
let result_slice = arena.bump_vec_into_slice(temp_vec);

// Create and return a DataValue array
Ok(arena.alloc(DataValue::Array(result_slice)))</code></pre>
                </div>
                
                <h3 class="mdc-typography--subtitle1">Choosing Between CustomSimple and CustomAdvanced</h3>
                <p class="mdc-typography--body1">
                    Key factors to consider:
                </p>
                <ul class="mdc-typography--body1">
                    <li><strong>CustomSimple</strong>: Easier to implement, works well for scalar operations</li>
                    <li><strong>CustomAdvanced</strong>: More complex but offers full control, required for arrays and objects</li>
                    <li>Use CustomSimple when possible for simpler code maintenance</li>
                    <li>Use CustomAdvanced when performance or complex data structures are required</li>
                </ul>
                
                <p class="mdc-typography--body1">
                    For detailed implementation guidance, see the <a href="https://github.com/codetiger/datalogic-rs/blob/main/CUSTOM_OPERATORS.md" target="_blank">Custom Operators documentation</a>.
                </p>
            </section>
            
            <section id="wasm-support" class="tutorial-section">
                <h2 class="mdc-typography--headline5">WebAssembly Support</h2>
                <p class="mdc-typography--body1">
                    DataLogic-rs can be compiled to WebAssembly for use in web applications:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-rust">// In your lib.rs
use wasm_bindgen::prelude::*;
use datalogic_rs::DataLogic;

#[wasm_bindgen]
pub struct JsDataLogic {
    engine: DataLogic,
}

#[wasm_bindgen]
impl JsDataLogic {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        JsDataLogic {
            engine: DataLogic::new(),
        }
    }
    
    #[wasm_bindgen]
    pub fn evaluate(&self, rule: &str, data: &str) -> Result<String, JsValue> {
        match self.engine.evaluate_str(rule, data, None) {
            Ok(result) => Ok(result.to_string()),
            Err(e) => Err(JsValue::from_str(&e.to_string())),
        }
    }
}</code></pre>
                </div>
                
                <p class="mdc-typography--body1">
                    Then in JavaScript, you can use it like this:
                </p>
                
                <div class="code-block mdc-card">
                    <pre><code class="language-javascript">import { JsDataLogic } from 'datalogic-rs';

const logic = new JsDataLogic();
const rule = '{"==":[{"val":"temperature"},0]}';
const data = '{"temperature":0}';

try {
    const result = logic.evaluate(rule, data);
    console.log(`Result: ${result}`); // Outputs: Result: true
} catch (error) {
    console.error(`Error: ${error}`);
}</code></pre>
                </div>
            </section>
            
            <section id="next-steps" class="tutorial-section">
                <h2 class="mdc-typography--headline5">Next Steps</h2>
                <p class="mdc-typography--body1">
                    Now that you understand the basics of DataLogic-rs, you can:
                </p>
                
                <ul class="mdc-typography--body1">
                    <li>Explore the <a href="operators.html">Operators Documentation</a> to learn about all available operators</li>
                    <li>Try out examples in the <a href="playground.html">Interactive Playground</a></li>
                    <li>Check out the <a href="https://github.com/codetiger/datalogic-rs">GitHub repository</a> for more examples and advanced usage</li>
                    <li>Read <a href="https://github.com/codetiger/datalogic-rs/blob/main/ARENA.md" target="_blank">ARENA.md</a> for detailed information on memory management</li>
                </ul>
            </section>
        </main>

        <footer class="footer mdc-typography--caption">
            <p>DataLogic-rs is a Rust implementation compatible with 
                <a href="https://jsonlogic.com" target="_blank">JSONLogic</a> and other expression formats. 
                View the <a href="https://github.com/codetiger/datalogic-rs" target="_blank">source code</a>.
            </p>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script type="module" src="jsonlogic.js"></script>
    <script type="module">
        import { JsonLogicEvaluator } from './jsonlogic.js';

        let evaluator;

        async function initWasm() {
            evaluator = new JsonLogicEvaluator();
            await evaluator.initialize();
        }

        function setupEditor(ruleId, dataId, resultId, initialRule, initialData) {
            const rulesEditor = CodeMirror.fromTextArea(document.getElementById(ruleId), {
                mode: { name: 'javascript', json: true },
                theme: 'material',
                lineNumbers: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                tabSize: 2
            });

            const dataEditor = CodeMirror.fromTextArea(document.getElementById(dataId), {
                mode: { name: 'javascript', json: true },
                theme: 'material',
                lineNumbers: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                tabSize: 2
            });

            const resultEditor = CodeMirror.fromTextArea(document.getElementById(resultId), {
                mode: { name: 'javascript', json: true },
                theme: 'material',
                lineNumbers: true,
                matchBrackets: true,
                readOnly: true,
                tabSize: 2
            });
            
            // Set initial values
            rulesEditor.setValue(JSON.stringify(initialRule, null, 2));
            dataEditor.setValue(JSON.stringify(initialData, null, 2));
            
            // Mark result editor as readonly
            resultEditor.getWrapperElement().classList.add('CodeMirror-readonly');
            
            // Add change handlers to update result
            const updateResult = async () => {
                try {
                    const rules = JSON.parse(rulesEditor.getValue());
                    let data = {};
                    
                    try {
                        const dataValue = dataEditor.getValue().trim();
                        if (dataValue) {
                            data = JSON.parse(dataValue);
                        }
                    } catch (err) {
                        resultEditor.setValue(`Data Error: ${err.message}`);
                        return;
                    }
                    
                    const result = await evaluator.evaluate(rules, data);
                    
                    if (result.success) {
                        resultEditor.setValue(JSON.stringify(result.result, null, 2));
                    } else {
                        resultEditor.setValue(`Error: ${result.error}`);
                    }
                } catch (err) {
                    resultEditor.setValue(`Rule Error: ${err.message}`);
                }
            };
            
            rulesEditor.on('change', updateResult);
            dataEditor.on('change', updateResult);
            
            // Initial evaluation
            updateResult();
            
            return { rulesEditor, dataEditor, resultEditor };
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            await initWasm();
            
            // Initialize code highlighting
            hljs.highlightAll();
            
            // Set up the tutorial examples
            setupEditor('intro-rule-editor', 'intro-data-editor', 'intro-result-editor', 
                { "==": [1, 1] }, {});
                
            setupEditor('comparison-rule-editor', 'comparison-data-editor', 'comparison-result-editor', 
                { "==": [3, 3] }, {});
                
            setupEditor('arithmetic-rule-editor', 'arithmetic-data-editor', 'arithmetic-result-editor', 
                { "+": [2, 3] }, {});
                
            setupEditor('variables-rule-editor', 'variables-data-editor', 'variables-result-editor', 
                { "val": ["user", "name"] }, { user: { name: "John", age: 30 } });
                
            setupEditor('array-rule-editor', 'array-data-editor', 'array-result-editor', 
                { "some": [{ "val": "items" }, { ">=": [{ "val": "qty" }, 10] }] }, 
                { items: [{ qty: 5, id: "A" }, { qty: 15, id: "B" }, { qty: 3, id: "C" }] });
                
            setupEditor('condition-rule-editor', 'condition-data-editor', 'condition-result-editor', 
                { "if": [{ "<": [{ "val": "age" }, 18] }, "Minor", "Adult"] }, 
                { age: 15 });
                
            setupEditor('complex-rule-editor', 'complex-data-editor', 'complex-result-editor', 
                { "and": [
                    { ">=": [{ "val": "age" }, 18] },
                    { "or": [
                        { "==": [{ "val": "membership" }, "premium"] },
                        { ">=": [{ "val": "purchases" }, 5] }
                    ]}
                ]}, 
                { age: 25, membership: "basic", purchases: 7 });
                
            setupEditor('try-rule-editor', 'try-data-editor', 'try-result-editor', 
                { "try": [{ "val": ["non_existent", "property"] }, { "throw": "Property not found!" }] }, 
                {});
                
            // Set up navigation
            const navLinks = document.querySelectorAll('.tutorial-nav-list a');
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
                });
            });
            
            // Initialize MDC components
            mdc.autoInit();
            
            // Initialize ripple effect for all buttons
            const buttons = document.querySelectorAll('.mdc-button');
            buttons.forEach(button => {
                mdc.ripple.MDCRipple.attachTo(button);
            });
        });
    </script>
</body>
</html> 