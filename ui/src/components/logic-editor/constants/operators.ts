import type { OperatorMeta, OperatorCategory } from '../types';

// Complete registry of JSONLogic operators
export const OPERATORS: Record<string, OperatorMeta> = {
  // Variable operators
  var: {
    name: 'var',
    category: 'variable',
    label: 'var',
    description: 'Get a value from the data object',
    minArgs: 1,
    maxArgs: 2,
    argLabels: ['path', 'default'],
  },
  val: {
    name: 'val',
    category: 'variable',
    label: 'val',
    description: 'Get a constant value',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['path'],
  },
  exists: {
    name: 'exists',
    category: 'variable',
    label: 'exists',
    description: 'Check if a variable exists',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['path'],
  },

  // Comparison operators
  '==': {
    name: '==',
    category: 'comparison',
    label: '==',
    description: 'Loose equality',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['left', 'right'],
  },
  '===': {
    name: '===',
    category: 'comparison',
    label: '===',
    description: 'Strict equality',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['left', 'right'],
  },
  '!=': {
    name: '!=',
    category: 'comparison',
    label: '!=',
    description: 'Loose inequality',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['left', 'right'],
  },
  '!==': {
    name: '!==',
    category: 'comparison',
    label: '!==',
    description: 'Strict inequality',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['left', 'right'],
  },
  '>': {
    name: '>',
    category: 'comparison',
    label: '>',
    description: 'Greater than',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['left', 'right'],
  },
  '>=': {
    name: '>=',
    category: 'comparison',
    label: '>=',
    description: 'Greater than or equal',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['left', 'right'],
  },
  '<': {
    name: '<',
    category: 'comparison',
    label: '<',
    description: 'Less than',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['left', 'right'],
  },
  '<=': {
    name: '<=',
    category: 'comparison',
    label: '<=',
    description: 'Less than or equal',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['left', 'right'],
  },

  // Logical operators
  and: {
    name: 'and',
    category: 'logical',
    label: 'AND',
    description: 'Logical AND - all conditions must be true',
    minArgs: 1,
  },
  or: {
    name: 'or',
    category: 'logical',
    label: 'OR',
    description: 'Logical OR - at least one condition must be true',
    minArgs: 1,
  },
  '!': {
    name: '!',
    category: 'logical',
    label: 'NOT',
    description: 'Logical NOT - negates the value',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },
  '!!': {
    name: '!!',
    category: 'logical',
    label: 'BOOL',
    description: 'Convert to boolean',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },

  // Arithmetic operators
  '+': {
    name: '+',
    category: 'arithmetic',
    label: '+',
    description: 'Addition or string concatenation',
    minArgs: 1,
  },
  '-': {
    name: '-',
    category: 'arithmetic',
    label: '-',
    description: 'Subtraction',
    minArgs: 1,
    maxArgs: 2,
    argLabels: ['left', 'right'],
  },
  '*': {
    name: '*',
    category: 'arithmetic',
    label: 'ร',
    description: 'Multiplication',
    minArgs: 2,
  },
  '/': {
    name: '/',
    category: 'arithmetic',
    label: 'รท',
    description: 'Division',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['dividend', 'divisor'],
  },
  '%': {
    name: '%',
    category: 'arithmetic',
    label: '%',
    description: 'Modulo',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['dividend', 'divisor'],
  },
  max: {
    name: 'max',
    category: 'arithmetic',
    label: 'max',
    description: 'Maximum value',
    minArgs: 1,
  },
  min: {
    name: 'min',
    category: 'arithmetic',
    label: 'min',
    description: 'Minimum value',
    minArgs: 1,
  },
  abs: {
    name: 'abs',
    category: 'arithmetic',
    label: 'abs',
    description: 'Absolute value',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },
  ceil: {
    name: 'ceil',
    category: 'arithmetic',
    label: 'ceil',
    description: 'Round up to nearest integer',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },
  floor: {
    name: 'floor',
    category: 'arithmetic',
    label: 'floor',
    description: 'Round down to nearest integer',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },

  // String operators
  cat: {
    name: 'cat',
    category: 'string',
    label: 'cat',
    description: 'Concatenate strings',
    minArgs: 1,
  },
  substr: {
    name: 'substr',
    category: 'string',
    label: 'substr',
    description: 'Extract substring',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['string', 'start', 'length'],
  },
  in: {
    name: 'in',
    category: 'string',
    label: 'in',
    description: 'Check if string contains substring or array contains element',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['needle', 'haystack'],
  },
  length: {
    name: 'length',
    category: 'string',
    label: 'length',
    description: 'Get string or array length',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['value'],
  },
  starts_with: {
    name: 'starts_with',
    category: 'string',
    label: 'starts_with',
    description: 'Check if string starts with substring',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['string', 'prefix'],
  },
  ends_with: {
    name: 'ends_with',
    category: 'string',
    label: 'ends_with',
    description: 'Check if string ends with substring',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['string', 'suffix'],
  },
  upper: {
    name: 'upper',
    category: 'string',
    label: 'upper',
    description: 'Convert to uppercase',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['string'],
  },
  lower: {
    name: 'lower',
    category: 'string',
    label: 'lower',
    description: 'Convert to lowercase',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['string'],
  },
  trim: {
    name: 'trim',
    category: 'string',
    label: 'trim',
    description: 'Remove leading/trailing whitespace',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['string'],
  },
  split: {
    name: 'split',
    category: 'string',
    label: 'split',
    description: 'Split string by delimiter',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['string', 'delimiter'],
  },

  // Array operators
  map: {
    name: 'map',
    category: 'array',
    label: 'map',
    description: 'Transform each element',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['array', 'expression'],
  },
  filter: {
    name: 'filter',
    category: 'array',
    label: 'filter',
    description: 'Filter elements by condition',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['array', 'condition'],
  },
  reduce: {
    name: 'reduce',
    category: 'array',
    label: 'reduce',
    description: 'Reduce array to single value',
    minArgs: 3,
    maxArgs: 3,
    argLabels: ['array', 'expression', 'initial'],
  },
  all: {
    name: 'all',
    category: 'array',
    label: 'all',
    description: 'Check if all elements match condition',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['array', 'condition'],
  },
  some: {
    name: 'some',
    category: 'array',
    label: 'some',
    description: 'Check if any element matches condition',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['array', 'condition'],
  },
  none: {
    name: 'none',
    category: 'array',
    label: 'none',
    description: 'Check if no elements match condition',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['array', 'condition'],
  },
  merge: {
    name: 'merge',
    category: 'array',
    label: 'merge',
    description: 'Merge multiple arrays',
    minArgs: 1,
  },
  sort: {
    name: 'sort',
    category: 'array',
    label: 'sort',
    description: 'Sort array elements',
    minArgs: 1,
    maxArgs: 2,
    argLabels: ['array', 'expression'],
  },
  slice: {
    name: 'slice',
    category: 'array',
    label: 'slice',
    description: 'Extract portion of array',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['array', 'start', 'end'],
  },

  // Control flow operators
  if: {
    name: 'if',
    category: 'control',
    label: 'if',
    description: 'Conditional branching',
    minArgs: 2,
    argLabels: ['condition', 'then', 'else'],
  },
  '?:': {
    name: '?:',
    category: 'control',
    label: '?:',
    description: 'Ternary operator',
    minArgs: 3,
    maxArgs: 3,
    argLabels: ['condition', 'then', 'else'],
  },
  '??': {
    name: '??',
    category: 'control',
    label: '??',
    description: 'Nullish coalescing',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['value', 'fallback'],
  },

  // DateTime operators
  now: {
    name: 'now',
    category: 'datetime',
    label: 'now',
    description: 'Current timestamp',
    minArgs: 0,
    maxArgs: 0,
  },
  datetime: {
    name: 'datetime',
    category: 'datetime',
    label: 'datetime',
    description: 'Create datetime from components',
    minArgs: 1,
    maxArgs: 7,
    argLabels: ['year', 'month', 'day', 'hour', 'minute', 'second', 'ms'],
  },
  timestamp: {
    name: 'timestamp',
    category: 'datetime',
    label: 'timestamp',
    description: 'Convert to timestamp',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['datetime'],
  },
  parse_date: {
    name: 'parse_date',
    category: 'datetime',
    label: 'parse_date',
    description: 'Parse date string',
    minArgs: 1,
    maxArgs: 2,
    argLabels: ['string', 'format'],
  },
  format_date: {
    name: 'format_date',
    category: 'datetime',
    label: 'format_date',
    description: 'Format date to string',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['datetime', 'format'],
  },
  date_diff: {
    name: 'date_diff',
    category: 'datetime',
    label: 'date_diff',
    description: 'Difference between dates',
    minArgs: 2,
    maxArgs: 3,
    argLabels: ['date1', 'date2', 'unit'],
  },

  // Error handling operators
  try: {
    name: 'try',
    category: 'error',
    label: 'try',
    description: 'Try expression with fallback',
    minArgs: 2,
    maxArgs: 2,
    argLabels: ['expression', 'fallback'],
  },
  throw: {
    name: 'throw',
    category: 'error',
    label: 'throw',
    description: 'Throw an error',
    minArgs: 1,
    maxArgs: 1,
    argLabels: ['message'],
  },
};

// Get operator metadata with fallback for unknown operators
export function getOperatorMeta(operator: string): OperatorMeta {
  return (
    OPERATORS[operator] || {
      name: operator,
      category: 'literal' as OperatorCategory,
      label: operator,
      description: `Unknown operator: ${operator}`,
    }
  );
}

// Check if a key is a known operator
export function isOperator(key: string): boolean {
  return key in OPERATORS;
}
